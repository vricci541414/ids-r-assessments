---
title: Tipos de Datos
description: >-
  Vamos a hacer un repaso de los distintos tipos de variables que hay en R y cómo trabajar con ellas. 
  
---

## str

```yaml
type: MultipleChoiceExercise
key: 0e2a0ce37a
lang: r
xp: 50
skills:
  - 1
```

Vamos a utilizar el siguiente set de datos para este módulo. 
Corran este código en la consola. 


```{r}
library(dslabs)
data(murders)
```

Después, utilizaremos la función `str` para examinar la estructura del objeto llamado `murders`. Podemos ver que este objeto es un data frame con 51 filas y 5 columnas.  

¿Cuál de las siguientes respuestas describe las variables en el data frame? 

`@possible_answers`
- Los 51 estados
- La tasa de asesinatos para todos los 50 estados y DC 
- El nombre del estado, la abreviación del nombre del estado, la región del nombre del estado, la región del estado, la población del estado y el número total de asesinatos para 2010. 

- `str` no muestra información relevante 

`@hint`
Revise el resultado que aparece cuando escribe la instrucción `str(murders)`.

`@pre_exercise_code`
```{r}
library(dslabs)
str(murders) 
```

`@sct`
```{r}
msg1 = "¡Inténtelo de nuevo! Lea la pregunta de nuevo."
msg2 = "¡Inténtelo de nuevo! Lea la pregunta cuidadosamente."
msg3 = "Bien hecho. Ahora proceda al siguiente ejercicio"
msg4 = "¡Inténtelo de nuevo! Relea lo que la pregunta busca"
test_mc(correct = 3, feedback_msgs = c(msg1,msg2,msg3,msg4))
```

---

## Nombres de variables

```yaml
type: NormalExercise
key: 7455b7cb2b
lang: r
xp: 100
skills:
  - 1
```
En la pregunta anterior, vimos las variables diferentes que son parte de este set de datos por medio del resultado de la función `str()`. La función `names()` está diseñada específicamente para extraer los nombres de las columnas de una base de datos.

`@instructions`
Para esta pregunta, utilizaremos la función `names()` para extraer los nombres de las columnas de la base de datos `murders`.
- ¿Cuáles son los nombres de variables utilizados en la base de datos `murders` para las cinco variables?

`@hint`
Asegúrese de escribir el nombre de la base de datos - `murders` - en paréntesis después de names.

`@pre_exercise_code`
```{r}
library(dslabs)
data(murders)
```

`@sample_code`
```{r}
# Cargar paquetes y datos 

library(dslabs)
data(murders)

# Utilizar la función names para extraer los nombres de las variables  

```

`@solution`
```{r}
# Cargar paquetes y datos

library(dslabs)
data(murders)

# Utilice la función names para extraer los nombres de las variables  
names(murders)
```

`@sct`
```{r}
test_error()
test_function("names", incorrect_msg = "Asegúrese de haber escrito el nombre del set de datos.") 
test_output_contains ("names(murders)",times=1,incorrect_msg= "Asegúrese de usar la función `names` en el set de datos`murders`")
success_msg("¡Bien hecho!")
```

---

## Examinar variables

```yaml
type: NormalExercise
key: efedf86c1b
lang: r
xp: 100
skills:
  - 1
```

En este módulo hemos aprendido que cada variable tiene una clase. Por ejemplo, la clase o tipo puede ser *categórica*, *numérica* or *logica*. La función `class()` puede ser usada para determinar la clase de un objeto. 

Aquí vamos a determinar la clase de una de las variables en el data frame `murders`. Para extraer las variables de la base utilizaremos `$`, referido como el operador de acceso.

En el editor les mostramos un ejemplo de cómo hacer esto. Ahora intentémoslo por nosotros mismos. 

`@instructions`
Utilice el operador de acceso `$` para extraer las abreviaciones de los nombres de los estados y asígnelos como el objeto `a`.
¿Qué clase es este objeto?


`@hint`
Recuerde asignar las abreviaciones de los nombres de los estados al objeto `a`.

`@pre_exercise_code`
```{r}
library(dslabs)
data(murders)
```

`@sample_code`
```{r}
# Para acceder a la variable de población del set de datos murders use este código:
p <- murders$population 

# Para determinar la clase del objeto `p` usamos este código:
class(p)

# Utilice el operador de acceso para extraer las abreviaciones de los nombres de los estados y asígnelo a "a" 

# Determine la clase de a

```

`@solution`
```{r}

# Para acceder a la variable de población del set de datos murders use este código:
m <- murders$population 

# Para determinar la clase del objeto `m` usamos este código:
class(m)

# Utilice el operador de acceso para extraer las abreviaciones de los nombres de los estados y asígnelo a "a"
a <- murders$abb 

# Determine la clase de a
class(a)  
```

`@sct`
```{r}
test_error()
test_object ("a", undefined_msg = "Necesita redefinir el objeto `a`.", incorrect_msg = "Asegúrese de guardar `abb` en el objeto `a`.")
test_function("class",index=2,incorrect_msg = "Mantenga el código de muestra cuando suba su solución.")
test_function_result("class",index=2,incorrect_msg = "¡Inténtelo de nuevo!")
test_student_typed("$", times = 2, not_typed_msg = "Asegúrese de utilizar el operador de acceso $.")
success_msg("¡Excelente! Ahora ya sabe cuál es la clase del objeto `abb`. Explore con las otras variables para descubrir el tipo de variables que hay en el set de datos!")
```

---

## Múltiples maneras de acceder a las variables

```yaml
type: NormalExercise
key: daeef502c6
lang: r
xp: 100
skills:
  - 1
```

Hay una lección importante que debe aprender lo más pronto posible y es que hay múltiples formas de hacer cosas en R. Por ejemplo, para generar los primeros cinco números enteros `1:5` y `seq(1,5)` dan el mismo resultado. 

También hay múltiples maneras de acceder variables en un data frame. Por ejemplo, podemos usar dos corchetes `[[` en lugar del operador de acceso `$`. Puede encontrar código ejemplificando lo anterior en el editor. 

Si en lugar de eso, trata de acceder una columna con un solo corchete,  

```{r}
murders["population"]
```
R provee un subconjunto del data frame original que contiene solamente esta columna. Este nuevo objeto será de la clase `data.frame` en lugar de un vector. Para acceder a la columna misma, tiene que utilizar o el operador de acceso `$` o los dobles corchetes `[[`.

Los paréntesis, en contraste, son utilizados con fnciones para indicar qué argumento debe hacer una función. Por ejemplo, cuando usamos `class(p)` en la pregunta pasada, quisimos que la función `class` hiciera algo relacionado con el argumento `p`.

Esto es solo un ejemplo de cómo R puede ser un poco This is an example of how R can be a bit idiosincrásico algunas veces. Es común confundirse con estos detalles al comenzar con el uso de R. 

`@instructions`
- Utilice los corchetes dobles `[[` para extraer las abreviaciones de los nombres de los estados y asignarlos al objeto `b`. 
- Después use la función `identical` para determinar si `a`, como fue definido en ejercicios anteriores y `b` son lo mismo.

`@hint`
Tendrá que usar dos sets de corchetes. 

`@pre_exercise_code`
```{r}
library(dslabs)
data(murders)
a <- murders$abb 
```

`@sample_code`
```{r}
# Extraemos la población así:
p <- murders$population

# Así hacemos lo mismo pero con los corchetes dobles:
o <- murders[["population"]] 

# Podemos confirmar si estos dos son lo mismo: 
identical(o, p)

# Usamos los corchetes para extraer `abb` de `murders` y asignarlos a `b`

# Revise si `a` y `b` son idénticos 

```

`@solution`
```{r}
# Extraemos la población así:
p <- murders$population

# Así hacemos lo mismo pero con los corchetes dobles:
o <- murders[["population"]] 

# Podemos confirmar si estos dos son lo mismo:
identical(o, p)

# Usamos los corchetes para extraer `abb` de `murders` y asignarlos a `b` 
b <- murders[["abb"]]

# Revise si `a` y `b` son idénticos 
identical(a,b)
```

`@sct`
```{r}
test_error()
test_object ("b", undefined_msg = "Tiene que definir el objeto `b`.", incorrect_msg = "Asegúrese de guardar la variable `abb` en el objeto `b`.")
test_function("identical",index=2)
test_student_typed("b<-murders[['abb']]",not_typed_msg = "Asegúrese de usar los dobles corchetes en lugar del operador de acceso $")
success_msg("¡Ahora ha aprendido diferentes maneras de hacer tareas idénticas en R! ¡Gran progreso!")
```

---

## Factores

```yaml
type: NormalExercise
key: 1f3a027666
lang: r
xp: 100
skills:
  - 1
```

Cuando usamos el comando `str()`, notamos que la columna de *region* guarda factor. Puede corroborar esto usando el comando `class` en la columna de *region*. 

La función `levels` nos muestra las categorías del factor. 

`@instructions`
- Para esta pregunta, combinaremos dos funciones anidadas para determinar el número de categorías únicas. 
Utilice las funciones `levels` y `length` para determinar el número de regiones definidas por este set de datos encontradas en `murders$region`.

`@hint`
Asegúrese de usar las funciones anidadas: `levels` dentro de `length`.

`@pre_exercise_code`
```{r}
library(dslabs)
data(murders)
```

`@sample_code`
```{r}
# Podemos ver la clase de la variable de la región usando class
class(murders$region)

# Determine el número de regiones incluidas en esta variable 

```

`@solution`
```{r}
# Podemos ver la clase de la variable de la región usando class
class(murders$region)

# Determine el número de regiones incluidas en esta variable 
length(levels(murders$region))

```

`@sct`
```{r}
test_error()
test_output_contains("length(levels(murders$region))", incorrect_msg = "Corra el código mencionado en las instrucciones exactamente como está.")
test_function("length")
test_function("levels")
success_msg("¡Bien hecho!")
```

---

## Tablas

```yaml
type: NormalExercise
key: 50874dd0d0
lang: r
xp: 100
skills:
  - 1
```

La función `table` toma un vector como y devuelve la frecuencia de cada elemento. (Note que verá la función `c()` utilizada en nuestro código de muestra, pero lo estamos usando ahí solamente para crear un vector al cual podamos aplicar la función `table()` como ejemplo.)

`@instructions`
Usaremos la función `table` para contestar esta pregunta.
- Utilice la función `table` en una línea de código para crear una tabla que muestre el número de estados por región.

`@hint`
Extraiga la *region* del set de datos `murders` usando `murders$region`. Si aplica la función `table` a este objeto, contará el número de veces que cada región aparece. 

`@pre_exercise_code`
```{r}
library(dslabs)
data(murders)
```

`@sample_code`
```{r}
# La "c" en `c()` es la abreviación de "concatenar," la cual es la acción de conectar objetos a una cadena 
# La función `c()` conecta todas las cadenas dentro de un solo vector, el cual podemos asignar a `x`
# Aquí estamos simplemente usando `c()` para generar un vector al cual podemos aplicar la función `table()` 
x <- c("a", "a", "b", "b", "b", "c")
# Aquí está un ejemplo de lo que la función tabe hace
table(x)

# Escriba una línea de código para mostrar el número de estados por región 

```

`@solution`
```{r}
# La "c" en `c()` es la abreviación de "concatenar," la cual es la acción de conectar objetos a una cadena 
# La función `c()` conecta todas las cadenas dentro de un solo vector, el cual podemos asignar a `x`
# Aquí estamos simplemente usando `c()` para generar un vector al cual podemos aplicar la función `table()` 
x <- c("a", "a", "b", "b", "b", "c")
# Aquí está un ejemplo de lo que la función tabe hace
table(x)

# Escriba una línea de código para mostrar el número de estados por región 
table(murders$region)

```

`@sct`
```{r}
test_error()
test_function("table",index=2, incorrect_msg = "Asegúrese de extraer la variable region del set de datos.",not_called_msg = "mantenga el código muestra.")
test_output_contains("table(murders$region)",incorrect_msg = "Use table en la variable murders$region.")
success_msg("¡Bien hecho! ¡Usted es un pro en hacer tablas en R!")
```

---

## Fin de la Evaluación 2

```yaml
type: PureMultipleChoiceExercise
key: 2af8480751
lang: r
xp: 50
skills:
  - 1
```

Este es el final de la tarea de programación para esta sección. Por favor NO SELECCIONE tareas adicionales en esta página. Por favor conteste la pregunta en esta página. Si selecciona en tareas adicionales, sus respuestas y calificación puede que no sean almacenadas. 

Seleccione "Maravilloso" para obtener los "puntos" para esta sección y regrese al curso en edX.

Ahora puede cerrar esta ventana y regresar a <a href='https://www.edx.org/course/data-science-r-basics-2'>curso</a>.

`@hint`
- ¡No es necesaria una pista!

`@possible_answers`
- [Maravilloso]
- No

`@feedback`
- ¡Genial! Ahora puede regresar al curso en edX!
- Ahora regrese al curso en edX!
